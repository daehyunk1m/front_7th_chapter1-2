---
alwaysApply: true
---

# 캘린더 일정 관리 애플리케이션 - 개발 규칙

## 프로젝트 구조

이 프로젝트는 React + TypeScript 기반의 캘린더 일정 관리 애플리케이션입니다.

### 디렉토리 구조

- `src/apis/` - API 통신 로직 (외부 데이터 페칭)
- `src/hooks/` - 커스텀 훅 (상태 관리 및 비즈니스 로직)
- `src/utils/` - 순수 함수로 구성된 유틸리티
- `src/__tests__/` - 테스트 파일 (난이도별 분류: easy._, medium._)
- `src/__mocks__/` - MSW 핸들러 및 모킹 데이터
- [src/types.ts](mdc:src/types.ts) - 전역 타입 정의
- [src/App.tsx](mdc:src/App.tsx) - 메인 애플리케이션 컴포넌트

## 코딩 컨벤션

### 1. TypeScript 규칙

- **Strict Mode 활성화**: 모든 타입은 명시적으로 정의
- **Interface 우선**: 객체 타입 정의 시 `interface` 사용
- **Union Type 활용**: 제한된 값의 집합은 union type으로 정의
  ```typescript
  type RepeatType = 'none' | 'daily' | 'weekly' | 'monthly' | 'yearly';
  ```

### 2. 네이밍 규칙

**파일명**:

- camelCase: `dateUtils.ts`, `eventOverlap.ts`
- 테스트: `easy.*.spec.ts`, `medium.*.spec.ts`
- 컴포넌트: PascalCase `App.tsx`

**함수명**:

- 동사 + 명사: `getWeekDates`, `formatDate`, `createNotificationMessage`
- Boolean 반환: `is` prefix (`isOverlapping`, `isDateInRange`)
- 이벤트 핸들러: `handle` prefix (`handleStartTimeChange`)

**변수명**:

- Boolean: `is`, `has` prefix (`isRepeating`, `hasError`)
- 한글 상수 허용: `const 초 = 1000; const 분 = 초 * 60;`

### 3. Import 순서 (필수)

반드시 다음 순서를 따르며, 그룹 간에는 빈 줄을 추가:

```typescript
// 1. External libraries (알파벳 순)
import { useState, useEffect } from 'react';

// 2. Internal modules (parent/sibling)
import { Event, EventForm } from '../types';
import { getTimeErrorMessage } from '../utils/timeValidation';
```

### 4. 코드 스타일 (Prettier)

- Single quotes
- 세미콜론 필수
- Print width: 100
- Tab width: 2 (spaces)
- Trailing comma: es5

## 아키텍처 패턴

### 관심사 분리 (Separation of Concerns)

**Hooks** - 상태 관리 및 부수 효과:

- `useEventForm` - 폼 상태 관리
- `useEventOperations` - API 통신 (CRUD)
- `useCalendarView` - 뷰 상태 관리
- `useNotifications` - 알림 로직
- `useSearch` - 검색 및 필터링

**Utils** - 순수 함수만:

- 외부 상태에 의존하지 않음
- 동일한 입력에 동일한 출력
- 부수 효과 없음
- JSDoc 주석 작성 권장

### 에러 처리 패턴

```typescript
// Early return 패턴 사용
if (!title || !date) {
  enqueueSnackbar('필수 정보를 입력해주세요.', { variant: 'error' });
  return;
}

// Try-catch로 API 에러 핸들링
try {
  const response = await fetch('/api/events');
  if (!response.ok) {
    throw new Error('Failed to fetch events');
  }
} catch (error) {
  console.error('Error:', error);
  enqueueSnackbar('에러 메시지', { variant: 'error' });
}
```

## UI/UX 가이드

### Material-UI 사용

- `Box`, `Stack`으로 레이아웃 구성
- `sx` prop으로 스타일링
- 접근성 속성 필수: `aria-label`, `data-testid`

### 레이아웃 구조

```
왼쪽(20%) - 일정 추가/수정 폼
중앙(flex:1) - 달력 뷰
오른쪽(30%) - 일정 목록
```

## 테스트 규칙

### 파일 네이밍

- `easy.*.spec.ts` - 단순 로직 (utils, 기본 hooks)
- `medium.*.spec.ts` - 복잡한 로직 (API, 통합 테스트)

### 테스트 구조

```typescript
describe('그룹명', () => {
  it('명확한 한글 설명으로 작성', () => {
    // Arrange, Act, Assert 패턴
  });
});
```

## 주의사항

1. **컴포넌트 분리**: [src/App.tsx](mdc:src/App.tsx)가 너무 크면 하위 컴포넌트로 분리 고려
2. **반복 일정 기능**: 현재 주석 처리됨 (8주차 과제 예정) - 구현하지 말 것
3. **API 엔드포인트**: `/api` prefix 사용 (Vite proxy 설정됨)
4. **상태 관리**: 전역 상태 라이브러리 없이 로컬 state + hooks 사용
5. **한글 메시지**: 사용자 피드백 메시지는 한글로 작성
