# 과제 체크포인트

### 필수 스펙

- 1. 반복 유형 선택
  - [x] 일정 생성 또는 수정 시 반복 유형을 선택할 수 있다.
  - [x] 반복 유형은 다음과 같다: 매일, 매주, 매월, 매년
    - [x] 31일에 매월을 선택한다면 → 매월 마지막이 아닌, 31일에만 생성하세요.
    - [x] 윤년 29일에 매년을 선택한다면 → 29일에만 생성하세요!
  - [x] 반복일정은 일정 겹침을 고려하지 않는다.

2. 반복 일정 표시
   - [x] 캘린더 뷰에서 반복 일정을 아이콘을 넣어 구분하여 표시한다.
3. 반복 종료
   - [x] 반복 종료 조건을 지정할 수 있다.
   - [x] 옵션: 특정 날짜까지
     - 예제 특성상, 2025-12-31까지 최대 일자를 만들어 주세요.
4. **반복 일정 수정**
   1. [x] ‘해당 일정만 수정하시겠어요?’ 라는 텍스트에서 ‘예’라고 누르는 경우 단일 수정
      - [x] 반복일정을 수정하면 단일 일정으로 변경됩니다.
      - [x] 반복일정 아이콘도 사라집니다.
   2. [x] ‘해당 일정만 수정하시겠어요?’ 라는 텍스트에서 ‘아니오’라고 누르는 경우 전체 수정
      - [x] 이 경우 반복 일정은 유지됩니다.
      - [x] 반복일정 아이콘도 유지됩니다.
5. **반복 일정 삭제**
   1. [x] ‘해당 일정만 삭제하시겠어요?’ 라는 텍스트에서 ‘예’라고 누르는 경우 단일 수정
      1. [x] 해당 일정만 삭제합니다.
   2. [x] ‘해당 일정만 삭제하시겠어요?’ 라는 텍스트에서 ‘아니오’라고 누르는 경우 전체 수정
      1. [x] 반복 일정의 모든 일정을 삭제할 수 있다.

## 기본 과제

### 공통 제출

- [x] 테스트를 잘 작성할 수 있는 규칙 명세
- [x] 명세에 있는 기능을 구현하기 위한 테스트를 모두 작성하고 올바르게 구현했는지
- [x] 명세에 있는 기능을 모두 올바르게 구현하고 잘 동작하는지

### 기본 과제(Easy)

- [x] AI 코드를 잘 작성하기 위해 추가로 작성했던 지침
- [x] 커밋별 올바르게 단계에 대한 작업
- [x] AI 도구 활용을 개선하기 위해 노력한 점 PR에 작성

### 기본 과제(Hard)

- [x] Agent 구현 명세 문서 또는 코드
- [x] 커밋별 올바르게 단계에 대한 작업
- [x] 결과를 올바로 얻기위한 history 또는 log
- [x] AI 도구 활용을 개선하기 위해 노력한 점 PR에 작성

### 심화 과제

- [x] 모든 질문에 대해 꼼꼼하게 정리했는지
  - [`report.md`](../report.md)

---

## 과제 셀프회고

<!-- 과제에 대한 회고를 작성해주세요 -->

+10-27
지난 주차의 과제는 쳐보면서 익히면 되지라는 생각으로 제공된 자료를 그리 꼼꼼히 보지 않고 바로 코드 구현을 시작했고
큰 이해도 없이 과제를 진행하니 쓸데 없는 구간에서 시간을 낭비하는 일이 많았다.
발제 자료와 주어진 문서 딥다이브가 중요함을 배웠고 가능한 제공한 링크나 공식문서도 한번씩 들어가보면서 개념을 충분히 익히려고 했다.
바로 Cursor를 켜서 한 줄이라도 치고 싶었지만 대신 Obsidian을 켰다.

+10-28
과제의 목표와 투두리스트를 정리하고 CLAUDE.md나 Test-guide-for-agent.md 등
에이전트가 수행하면서 참고할 수 있는 가이드 문서를 추가하고 업데이트

+10-29
클로드를 통해 필요한 에이전트 종류를 전달하고 요구사항을 정리해달라고 요청
클로드 코드를 통해 에이전트 추가

- feature-designer
- test-designer
- test-writer
- code-writer
- refactoring-expert
- orchestrator

chatGPT를 통해 에이전트가 갖춰야할 덕목(?)을 물어보고 덕목을 잘 갖추기 위한 기능을 구성할 수 있게 폴더 구조를 제안받았다.
폴더 구조를 기반으로 `.claude`안에 에이전트 문서와 에이전트가 참고할 수 있는 문서들을 생성하고 디벨롭했다.

```text
project/
│
├── docs/                  # 전체 프로젝트 기획 문서나 개요
│
├── references/           # 프로젝트 전반의 참고 자료
│
├── resources/            # 공통으로 사용하는 리소스나 에셋들
│
├── agents/            # {agent}.md 파일이 위치하는 곳
│
└── agent-docs/              # 각 에이전트별 폴더 구조
    │
    ├── orchestrator/
    │   ├── orchestrator.md
    │   ├── references/
    │   └── logs/
    │
    ├── feature-designer/
    │   ├── feature-designer.md
    │   ├── references/
    │   └── logs/
    │
    ├── test-designer/
    │   ├── test-designer.md
    │   ├── references/
    │   └── logs/
    │
    ├── test-maker/
    │   ├── test-maker.md
    │   ├── references/
    │   └── logs/
    │
    ├── developer/
    │   ├── developer.md
    │   ├── references/
    │   └── logs/
    │
    └── qa/
        ├── qa.md
        ├── references/
        └── logs/
```

+10-30
작동하는 에이전트를 만들기 위해서 우선 하나의 에이전트가 완성이 되야했다.
에이전트들을 조율하는 역할을 `Orchestrator`가 가지고 있어. 커서로 `.claude`의 폴더구조를 분석하고 분석 리포트를 기반으로 `Orchestrator`가 문서대로 잘 작동하려면 어떤 것들이 필요한지 물어보고
그 답변을 통해 에이전트들이 동작하는 전체 규칙을 규정하고 각각 어떤 인터페이스로 소통할지 정해 각각 참고할 수 있는 문서들을 생성해 그것을 기반으로 `Orchestrator`를 완성했다.

이후 나머지 에이전트들도 같은 방식으로 만들었고, 실제로 기능추가를 해보면서 세부 조정했다.
의도한 대로 기능추가가 잘 되고 로그도 남기고 깃도 스스로 남겨주는 등 에이전트가 구동되는 걸 보니 신기하고 감격스러웠다.

각 phase를 진행 하고 진행한 에이전트가 다음 작업자에게 작업 완료 리포트와 지시서를 전달해주는 handoff 전략을 사용한것이 유효했던 것 같다.

하지만 마지막 기능추가 때 할루시네이션으로 실제론 테스트가 전부 통과되지 않았는데 통과되었다고 해 다시 조정해보고 있다.

다행히 요건들을 다 정상적으로 구현됐다.

조직 구성과 조직이 사용할 방법론, 업무 프로세스들로 실제로 워크플로우가 돌아가는 것을 보니 시뮬레이션이 중요함을 느꼈다.

### 기술적 성장

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

TDD의 개념을 익히고 실제 사용을 해보면서 TDD의 강력함을 배움
검색도구나 튜터로서 LLM을 사용하는 단계에서 LLM을 다루는(?) 경험을 함
요즘 많이 보이는 AI에 대한 역량이 내가 생각한것 과 다르구나를 느낌.
에이전트를 만들 수 있게 됐음! 프로그래밍을 배운 이후로 오랜만에 파워를 가지게 된 기분을 느낌!

### 코드 품질

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

에이전트를 돌려가며 기능을 만들어내는 과정이 생각보다 길어서 엔터, 엔터를 누르며 프로세스를 진행시키느랴
생성된 코드의 품질을 확인해 볼 시간이 부족했다.

다만 LLM이니 코드외에 문서의 품질에 대해서 말을 하자면 문서가 다소 장황하긴 하지만 문서화에 필요한 요소와 탬플릿들을 큰 힘 들이지 않고 유지해나갈 수 있는 점은 우수한 것 같다.
문서 잘씀!

### 학습 효과 분석

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

듣기만 했던 A2A를 써보고 심지어 직접 만들어볼 수 있음 알았다.
개인적으로 놀라운 경험. 만들다가 방치된 다른 프로젝트에도 에이전트를 만들어 돌려보고 싶은 마음이 생겼다.
과제를 위해서 클로드 코드 max를 구독했는데 한달가량 돈 아깝지 않게 LLM을 혹사 시켜보고 연장할지 말지 결정해보려한다.

### 과제 피드백

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

최근 가장 관심이 있던 분야의 과제라서 기대가 됐었습니다.

기존에 많이 쓰듯 프롬프트를 통해 원하는 설계에 맞게 코드를 생성하고 구현하는거라 생각했는데,
의도를 분석하고 작업을 해줄 수 있는 에이전트를 만들어야 한다길래 처음엔 너무 막막했습니다.

선택한 LLM 종류에 따라 초기 세팅이나 룰의 우선순위 등이 세세하게 다른 것 같은데 처음에 헤매면서 조금씩 경험해보고 각 특징들을 알 수 있게 된 것 같아 좋았습니다.

## 리뷰 받고 싶은 내용

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 요청의 예시)
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 요청의 예시)
- 현재 함수와 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수를 더 명확하게 이름 지을 수 있는 방법에 대해 조언해주실 수 있나요?
- 현재 파일 단위로 코드가 분리되어 있지만, 모듈화나 계층화가 부족한 것 같습니다. 어떤 기준으로 클래스를 분리하거나 모듈화를 진행하면 유지보수에 도움이 될까요?
- MVC 패턴을 따르려고 했는데, 제가 구현한 구조가 MVC 원칙에 맞게 잘 구성되었는지 검토해주시고, 보완할 부분을 제안해주실 수 있을까요?
- 컴포넌트 간의 의존성이 높아져서 테스트하기 어려운 상황입니다. 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?
-->

이번 과제에서는 Claude의 subagent 기능을 활용해 에이전트를 제작했습니다.  
에이전트를 일종의 ‘함수’처럼 다루며, 입력값과 출력값이 동일할 때 항상 같은 결과를 내도록 규칙을 엄격히 제한했습니다.  
이 방식 덕분에 예측 가능성이 높아졌지만, 프로젝트 구조나 요구사항이 바뀌면 재사용성이 떨어지는 한계가 드러났습니다.

과제 문서에서 소개된 BMAD-Method는 이런 접근보다 더 발전된 아이디어로 보입니다.  
BMAD 방식은 각 에이전트에 페르소나와 역할을 부여해 ‘회사 내 에이전트 스쿼드’처럼 협업시키는 구조로 이해했습니다.  
이 접근은 다양한 프로젝트에도 유연하게 적용될 수 있을 것 같다는 생각이 듭니다.

- 현재처럼 입출력 규칙을 엄격히 고정한 함수형 에이전트 방식이 구조적으로 어떤 제약을 만드는지 알고 싶습니다.
- 이 접근을 유지하면서도 프로젝트 간 재사용성을 높일 수 있는 방법이 있을까요?
- BMAD 방식으로 에이전트를 설계하면, 실제로 여러 프로젝트에 범용적으로 활용 가능한 A2A 시스템을 만들 수 있을까요?
- 만약 가능하다면, 초기 설계 시 어떤 관점(페르소나 설계, 역할 정의, 입력·출력 구조 등)에 우선순위를 두는 게 좋을까요?
- 앞으로 에이전트를 만들 때, 함수형 접근과 BMAD 접근 중 어떤 방식으로 확장하는 게 장기적으로 더 효율적일지 조언 부탁드립니다.
